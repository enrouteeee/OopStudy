이 글은 '오브젝트' 책의 내용을 읽고 정리한 것 입니다.

훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다. 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라.

객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.

## 1\. 협력과 메시지

객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다. 그리고 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 메시지라는 것이다.

**메시지와 메시지 전송**

메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송이라고 부른다. 이때 메시지를 전송하는 객체를 메시지 전송자라고 부르고 메시지를 수신하는 객체를 메시지 수신자라고 부른다.

메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

**메시지와 메서드**

메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다. 객체지향이 메시지 전송과 메서드 호출을 명확하게 구분한다는 사실이 모호함의 덫으로 밀어 넣을 수도 있다. 메시지 전송을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다. 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.

메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다. 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다. 수신자는 어떤 클래스의 인스턴스인지, 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력이 가능하다.

**퍼블릭 인터페이스와 오퍼레이션**

객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다. 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용을 할 수 있다. 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라 부른다.

**시그니처**

오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다. 메서드는 이 시그니처에 구현을 더한 것이다.

중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다. 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

## 2\. 인터페이스와 설계 품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.

퍼블릭 인터페이스의 품질에 영향을 미치는 여러 원칙과 기법에 대해 살펴보겠다.

**디미터 법칙**

협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다. 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. 오직 하나의 도트만 사용하라.

클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다라고 이해해도 무방하다.

this 객체, 메서드의 매개변수, this의 속성, this의 속성인 컬렉션의 요소, 메서드 내에서 생성된 지역 객체

```
//디미터 법칙을 위반하는 코드의 전형적인 모습
screening.getMovie().getDiscountConditions();
```

디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.

**묻지 말고 시켜라**

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다. 구현하고 있는 로직은 메시지 수신자가 담당해야 할 책임일 것이다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다. '묻지 말고 시켜라' 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.

하지만 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다. 훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안 된다. 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야 한다.

**의도를 드러내는 인터페이스**

```
public class PeriodCondition{
	public boolean isSatisfiedByPeroid(Screening screening) {...}
}

public class SequenceCondition{
	public boolean isSatisfiedBySequence(Screening screening) {...}
}
```

이런 스타일은 좋지 않다. 그 이유는 메서드에 대해 제대로 커뮤니케이션하지 못한다. 클라이언트의 관점에서 두 메서드 모두 할인 조건을 판단하는 동일한 작업을 수행한다. 하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아차리기 어렵다. 더 큰 문제는 메서드 수준에서 캡슐화를 위반한다는 것이다. 이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다. 만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야 할 것이다.

메서드의 이름은 '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것이다. 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수도 있다. 하지만 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길이다.

## 3\. 원칙의 함정

위의 원칙들로 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있다. 하지만 절대적인 법칙은 아니다. 소프트웨어 설계에 법칙이란 존재하지 않는다. 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다.

잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 것이다. 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라. 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않는지를 판단할 수 있는 능력을 기르는 것이다.

**디미터 법칙은 하나의 도트(.)를 강제하는 규칙이** **아니다**

자바 8의 IntStream을 사용한 코드가 디미터 법칙을 위반한다고 생각할 것이다.

```
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```

이것은 디미터 법칙을 제대로 이해하지 못한 것이다. 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.

**결합도와 응집도의 충돌**

일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변경하는 코드는 묻지 말고 시켜라 스타일로 변경해야 한다.

질문하고, 판단하고, 상태를 변경하는 모든 코드를 객체 내부로 옮겨야 한다. 즉 위임 메서드를 추가하는 것이다. 이를 통해 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.

모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않은 오퍼레이션들이 공존하게 된다. 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.

클래스는 하나의 변경 원인만을 가져야 한다. 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다.

## 4\. 명령-쿼리 분리 원칙

가끔식은 필요에 따라 물어야 한다는 사실에 납득했다면 명령-쿼리 분리 원칙을 알아두면 도움이 될 것이다. 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.

명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다. 객체의 상태를 수정하는 오퍼레이션을 명령이라고 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.

명령-쿼리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.

1\. 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.

2\. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

"질문이 답변을 수정해서는 안 된다"는 것이다.

**반복 일정의 명령과 쿼리 분리하기**

명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다. 겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다. 가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것이다.

**명령-쿼리 분리와 참조 투명성**

명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다. 참조 투명성이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작설할 수 있다.

참조 투명성이란 무엇인가?

컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과의 존재 유무다. 프로그램에서 부수효과를 발생키시는 두 가지 대표적인 문법은 대입문과 함수다. 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다. 함수는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다. 부수효과를 이야기할 때 빠질 수 없는 것이 바로 참조 투명성이다. 참조 투명성이란 "어떤 표현식 e가 있을 때 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성"을 의미한다. 이처럼 어떤 값이 변하지 않는 성질을 불변성이라고 부른다.

수학에서는 함수는 어떤 값도 변경하지 않기 때문에 부수효과가 존재하지 않는다. 그리고 부수효과가 없는 불변의 세상에서는 모든 로직이 참조 투명성을 만족시킨다. 따라서 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다. 참조 투명성은 식의 순서를 변경하더라도 결과가 달라지지 않는다는 것이다.

객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 하지만 명령-쿼리 분리 원칙을 사용하면 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.

**책임에 초점을 맞춰라**